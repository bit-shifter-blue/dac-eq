# CLAUDE.md - EQ Advisor

This file provides guidance to Claude Code when working with the EQ Advisor project.

## Project Overview

**EQ Advisor** is a Python CLI tool and MCP server ecosystem for controlling Parametric EQ (PEQ) on USB DSP/DAC devices via HID protocol on macOS.

**Key capabilities:**
- Read/write PEQ settings to DSP devices (Tanchjim, Qudelix, Moondrop, etc.)
- Apply EQ profiles stored as JSON
- Integrate with IEM frequency response data (squiglink) and AutoEQ optimization
- Expose functionality via MCP servers for Claude Code workflows

**Based on:** devicePEQ by Pragmatic Audio (jeromeof)

---

## Architecture

### Core CLI Tool

```
cli.py (CLI entry point)
    │
    └── tools/peq_devices/
        ├── registry.py          # Device discovery and management
        ├── base.py              # Base classes (PEQProfile, FilterDefinition, DeviceCapabilities)
        ├── server.py            # MCP server for device control
        └── handlers/
            ├── tanchjim.py      # Tanchjim Fission/Bunny/One DSP handler
            ├── qudelix.py       # Qudelix 5K handler
            └── moondrop.py      # Moondrop FreeDSP/Rays/Marigold/MAY DSP handler
```

**Handler Pattern:**
- Each device handler implements: `read_peq()`, `write_peq()`, `set_pregain()`
- Handlers define device capabilities (max filters, supported types, gain/Q/freq ranges)
- Registry auto-discovers connected USB HID devices and matches them to handlers

### MCP Server Ecosystem

Three interconnected MCP servers provide a complete EQ workflow:

```
┌─────────────────────┐
│  squiglink          │  Fetch IEM frequency response measurements
│  tools/squiglink/   │  Sources: Crinacle, Super Review, manufacturer databases
│  server.py          │  Cache: cache/fr/{iem}/{variant}.csv
└──────────┬──────────┘
           │ FR data (file path to cached CSV)
           ▼
┌─────────────────────┐
│  autoeq             │  Compute optimal PEQ filters to match target curves
│  tools/autoeq/      │  Uses scipy optimization, supports Harman IE 2019, etc.
│  server.py          │  Targets: cache/targets/*.csv
│  optimizer.py       │
└──────────┬──────────┘
           │ {pregain, filters}
           ▼
┌─────────────────────┐
│  peq-devices        │  Write PEQ to connected DSP device
│  tools/peq_devices/ │  Wraps device handlers as MCP tools
│  server.py          │  Profiles: cache/peq/{device}/{iem}/{variant}/*.json
└─────────────────────┘
```

**MCP Configuration:** `.mcp.json` in project root
- All 3 servers use unified Python virtual environment in `venv/`
- Servers are project-scoped (only available when working in `eq-advisor/` directory)

---

## Development Setup

### Prerequisites

**Installation via `install.sh` (recommended):**
```bash
./install.sh
```
This automatically sets up the unified virtual environment with all dependencies.

**Manual setup (advanced):**
```bash
# Create unified virtual environment
python3.11 -m venv venv
source venv/bin/activate

# Install all dependencies
pip install -r requirements-all.txt

# Verify device detection
python cli.py --list
```

### Project Structure

```
eq-advisor/
├── cli.py                    # CLI entry point
├── streamlit_app.py          # Streamlit web interface (prototype)
├── requirements.txt          # Python dependencies
├── .mcp.json                 # MCP server configuration (generated by install.sh)
├── config.toml               # Streamlit app configuration
│
├── tools/                    # MCP servers & libraries (distributed)
│   ├── peq_devices/          # Device control + MCP server
│   │   ├── __init__.py
│   │   ├── base.py           # Core data structures
│   │   ├── registry.py       # Device discovery
│   │   ├── server.py         # MCP server
│   │   └── handlers/         # Device-specific implementations
│   │       ├── tanchjim.py
│   │       ├── qudelix.py
│   │       └── moondrop.py
│   │
│   ├── squiglink/            # IEM FR data + MCP server
│   │   └── server.py
│   │
│   ├── autoeq/               # EQ optimization + MCP server
│   │   ├── server.py
│   │   └── optimizer.py
│   │
│   ├── tool_definitions.py   # Claude API tool schemas (for Streamlit)
│   └── tool_executor.py      # Tool execution logic (for Streamlit)
│
├── cache/                    # Persistent data (user-specific, mostly gitignored)
│   ├── fr/                   # IEM frequency response measurements
│   │   └── {iem}/
│   │       └── {variant}.csv
│   ├── targets/              # AutoEQ target curves
│   │   └── {target}.csv
│   └── peq/                  # PEQ profiles
│       └── {device}/
│           ├── flat.json     # Device bypass profile
│           └── {iem}/
│               └── {variant}/
│                   └── {profile}.json
│
├── dev-tools/                # Development-only tools (not distributed)
│   ├── qudelix-probe/        # Qudelix debugging & protocol testing
│   └── tanchjim-probe/       # Tanchjim debugging & protocol testing
│
├── docs/                     # Documentation
│   ├── CLAUDE.md             # This file
│   └── SECURITY.md
│
└── archive/                  # Historical documentation and planning
    └── STREAMLIT_PROTOTYPE_PLAN.md
```

---

## CLI Usage

### Basic Commands

```bash
# Read current PEQ settings from device
python cli.py --read

# Write PEQ from JSON profile
python cli.py --json cache/peq/tanchjim-fission/generic/default/example_eq.json

# Write AutoEQ txt file (legacy format)
python cli.py --write eq_profile.txt

# Set pregain only (no filter changes)
python cli.py --pregain -6

# List all connected devices
python cli.py --list

# Select specific device by ID
python cli.py --device 0 --json profile.json

# Debug mode (show raw HID data)
python cli.py --debug
```

### Multi-Device Workflows

When multiple DSP devices are connected:
1. Run `--list` to see device IDs
2. Use `--device <ID>` to target specific device
3. Device IDs are 0-based indices

---

## PEQ Profile Format

**Primary format: JSON** (stored in `cache/peq/` directory)

```json
{
  "name": "Example EQ Profile",
  "pregain": -3.0,
  "filters": [
    {"freq": 100, "gain": -2.5, "q": 1.41, "type": "PK"},
    {"freq": 1000, "gain": 3.0, "q": 0.7, "type": "LSQ"},
    {"freq": 8000, "gain": -1.5, "q": 2.0, "type": "HSQ"}
  ]
}
```

**Filter types:**
- `PK` - Peaking filter (bell curve)
- `LSQ` - Low shelf
- `HSQ` - High shelf

**Storage structure:**
- Device bypass: `cache/peq/{device}/flat.json`
- Generic profiles: `cache/peq/{device}/generic/default/{profile}.json`
- IEM-specific: `cache/peq/{device}/{iem}/{variant}/{profile}.json`
- Example: `cache/peq/tanchjim-fission/moondrop-blessing-3/default/harman_ie_2019.json`

**Naming conventions:**
- All names normalized to lowercase with hyphens
- Use descriptive profile names: `harman_ie_2019.json`, `bass_boost.json`, etc.

**Legacy AutoEQ txt format:**
- CLI supports reading AutoEQ txt files with `--write`
- Convert txt files to JSON for use with MCP servers
- MCP workflow uses JSON exclusively

---

## MCP Workflow

### Complete Auto-EQ Pipeline

The 3 MCP servers work together seamlessly:

```python
# 1. Search for IEM and get FR data
mcp__squiglink__search_iems(query="Blessing 3")
mcp__squiglink__get_fr_data(database="crinacle", file="Moondrop_Blessing_3")
# Returns: {fr_file: "cache/fr/moondrop-blessing-3/default.csv", data_points: 480, cached: true}

# 2. Compute optimal EQ to match target
mcp__autoeq__compute_peq(
    fr_file="cache/fr/moondrop-blessing-3/default.csv",
    target="harman-ie-2019",
    constraints={"max_filters": 5}
)
# Returns: {pregain: -3.2, filters: [{freq: 100, gain: 2.5, q: 1.41, type: "PK"}, ...]}

# 3. Write to device
mcp__peq_devices__write_peq(
    filters=<from step 2>,
    pregain=-3.2,
    device_id=0
)
```

### MCP Tools Reference

**squiglink-mcp:**
- `search_iems(query)` - Search by brand/model name
- `get_fr_data(database, file)` - Fetch measurement data
- `list_databases()` - Show available databases
- `list_cached()` - Show locally cached measurements

**autoeq:**
- `compute_peq(fr_file, target, constraints)` - Generate optimal filters from cached FR data
- `compute_peq_from_fr(fr_file_measured, fr_file_target, constraints)` - Match measured to target FR
- `apply_peq_to_fr(fr_file, filters, pregain)` - Apply PEQ and return resulting FR
- `list_targets()` - Show available target curves
- `export_target(name)` - Export target as frequency/dB pairs
- `export_peq(pregain, filters)` - Export as JSON

**Note:** All autoeq tools now use **file paths** instead of data arrays for efficiency. FR data is cached in `cache/fr/`, targets in `cache/targets/`.

**peq-devices:**
- `list_devices()` - List connected DSP devices
- `get_device_capabilities(device_id)` - Get device specs
- `read_peq(device_id?)` - Read current settings (if supported)
- `write_peq(filters, pregain?, device_id?)` - Write EQ to device
- `set_pregain(pregain, device_id?)` - Set pregain only
- `load_preset(preset_index, group?, device_id?)` - Load preset from Qudelix device storage *(Qudelix only)*
- `save_preset(preset_index, group?, device_id?)` - Save current EQ to Qudelix preset slot *(Qudelix only)*
- `set_eq_mode(mode, device_id?)` - Switch Qudelix EQ mode (usr_spk/b20) *(Qudelix only)*
- `get_preset_name(preset_index, device_id?)` - Get Qudelix preset name *(Qudelix only)*
- `set_preset_name(preset_index, name, device_id?)` - Set Qudelix preset name *(Qudelix only)*

**Auto-selection:** If only one device is connected, `device_id` parameter is optional.

---

## Supported Devices

### Currently Implemented

| Device | Handler | Read | Write | Max Filters | Notes |
|--------|---------|------|-------|-------------|-------|
| Tanchjim Fission | `tanchjim.py` | ✓ | ✓ | 5 | Fully supported |
| Tanchjim Bunny DSP | `tanchjim.py` | ✓ | ✓ | 5 | Fully supported |
| Tanchjim One DSP | `tanchjim.py` | ✓ | ✓ | 5 | Fully supported |
| Qudelix 5K | `qudelix.py` | ✓ | ✓ | 10 | V3 protocol, USR EQ group (see below) |
| Moondrop FreeDSP Pro | `moondrop.py` | ✓ | ✓ | 8 | DSP cable, Conexant protocol |
| Moondrop FreeDSP Mini | `moondrop.py` | ✓ | ✓ | 8 | DSP cable, Conexant protocol |
| Moondrop Rays | `moondrop.py` | ✓ | ✓ | 8 | Gaming IEM with DSP |
| Moondrop Marigold | `moondrop.py` | ✓ | ✓ | 8 | IEM with DSP |
| Moondrop MAY DSP | `moondrop.py` | ✓ | ✓ | 8 | IEM with DSP |
| ddHiFi DSP IEM - Memory | `moondrop.py` | ✓ | ✓ | 8 | Uses Moondrop protocol |

**Vendor IDs:**
- Tanchjim: `0x31B2`
- Qudelix: `0x0A12` (CSR/Qualcomm)
- Moondrop: `0x3302`, `0x0762`, `0x35D8`, `0x2FC6`, `0x0104`, `0xB445`, `0x0661`, `0x0666`, `0x0D8C` (WalkPlay/Conexant ecosystem)

### Qudelix 5K Notes

The Qudelix 5K has three independent EQ groups:
- **USR** (default): 10 bands, mono (chan_mask=0x01) - user preference EQ
- **SPK**: 10 bands, stereo (chan_mask=0x03) - speaker/IEM correction, has Both/L/R selector
- **B20**: 20 bands, mono (chan_mask=0x01) - extended parametric EQ, higher resolution, no L/R split

The handler defaults to USR EQ. Protocol uses V3 format (Q×1024, group-based commands).
Band params are bit-packed as 32-bit LE: `[rsv:4][Q:14][gain:10][filter:4]`

**Data Structure Differences (Verified Feb 13, 2026):**
- **USR/SPK**: Header(4) + Pregain(4) + FreqL(2×bands) + FreqR(2×bands) + Params(4×bands)
  - **88 bytes total**: Header(4) + Pregain(4) + FreqL(20) + FreqR(20) + Params(40)
  - **IMPORTANT**: Only ONE Params array exists (applies to FreqL only)
  - FreqR in USR is **UNUSED** - contains fixed template frequencies `[31, 63, 125, 250, 500, 1k, 2k, 4k, 8k, 16k]`
  - FreqR in SPK is **USED** for independent R channel EQ when L/R split is active
- **B20**: Header(4) + Pregain(4) + Freq(2×bands) + Params(4×bands)
  - **128 bytes total**: Header(4) + Pregain(4) + Freq(40) + Params(80)
  - No FreqR array - pure mono, more compact structure

**IMPORTANT LIMITATION - Stereo Channel Handling (Verified Feb 13, 2026):**

For SPK group (stereo with L/R selector), the handler has the following limitations:

- **Write:** Always writes identical filters to both L and R channels (`chan_mask=0x03`)
- **Read:** Only reads left channel frequencies (FreqL), ignores right channel (FreqR)
- **Impact:** Independent L/R channel EQ is NOT supported
  - If you manually set different L/R frequencies in the official Qudelix app, only the LEFT channel will be visible when reading
  - Writing with this handler will OVERWRITE any custom R channel settings with values identical to L channel
- **Why:** The handler assumes stereo means "same filter on both channels" to simplify implementation and maintain consistency with USR (mono) mode

**Note on FreqR arrays:**
- **USR**: FreqR is completely unused (architectural baggage from shared SPK structure)
- **SPK**: FreqR *could theoretically* store independent R channel data, but handler treats both channels as linked
- **B20**: No FreqR array (pure mono, compact structure)

If you need independent L/R EQ, use the official Qudelix app. This handler is designed for mono and "linked stereo" EQ workflows.

### Qudelix Preset Management

The Qudelix 5K has **on-device preset storage** with 20 custom slots per EQ group:

**Preset Index Ranges:**
- `0` - Flat (default)
- `1-21` - Factory presets (Acoustic, Bass Booster, Classical, etc.)
- `22-41` - Custom user presets (editable, 20 slots per group)
- `42-52` - QxOver target curves (Harman IE 2019, Diffuse Field, etc.) - SPK group only
- `53-58` - T71 device-specific presets

**Handler Methods:**
```python
# Load preset from device storage
handler.load_preset(group="USR", preset_index=22)

# Save current settings to preset slot
handler.save_preset(group="USR", preset_index=22)

# Switch EQ mode
handler.set_eq_mode(mode="usr_spk")  # or "b20"

# Preset naming (✅ Working as of v2.1)
name = handler.get_preset_name(preset_index=22, group="USR")
handler.set_preset_name(preset_index=22, name="Bass Boost", group="USR")
```

**MCP Tools:**
```python
# Load/save presets
mcp__dac_eq__load_preset(group="USR", preset_index=22)
mcp__dac_eq__save_preset(group="USR", preset_index=22)

# Mode switching
mcp__dac_eq__set_eq_mode(mode="usr_spk")

# Preset naming (✅ Working as of v2.1)
mcp__dac_eq__get_preset_name(preset_index=22)  # Returns preset name string
mcp__dac_eq__set_preset_name(preset_index=22, name="My EQ")  # Sets custom name
```

**EQ Modes:**
- `usr_spk`: USR and SPK groups active simultaneously
- `b20`: B20 group active (20-band or 10×2 stereo)

**Complete Workflow Example:**
```python
# 1. Write EQ to device
mcp__dac_eq__write_peq(
    filters=[
        {"freq": 100, "gain": 3.0, "q": 1.0, "type": "LSQ"},
        {"freq": 8000, "gain": -2.0, "q": 2.0, "type": "PK"}
    ],
    pregain=-2.0
)

# 2. Save to custom preset slot 22 (first custom slot)
mcp__dac_eq__save_preset(group="USR", preset_index=22)

# 3. Set a friendly name for the preset
mcp__dac_eq__set_preset_name(preset_index=22, name="Bass Boost")

# 4. Later, load the preset by index
mcp__dac_eq__load_preset(group="USR", preset_index=22)

# 5. Verify the name persisted
name = mcp__dac_eq__get_preset_name(preset_index=22)
# Returns: "Bass Boost"
```

**Important Notes:**
- Preset names persist across power cycles
- Empty names show as "Custom #N" in official Qudelix app
- Each EQ group (USR, SPK, B20) has independent preset names
- Direct `read_peq()`/`write_peq()` remain the primary interface for consistency with other handlers
- Preset operations are optional advanced features

### Moondrop DSP Notes

Moondrop DSP devices use the modern Conexant-based protocol:
- **Packet size:** 63 bytes (write), 64 bytes (read response)
- **Biquad encoding:** 5 coefficients × 32-bit signed integers, scaled by 2^30
- **Sample rate:** 96 kHz (assumed for biquad calculation)
- **Value scaling:** 256x for gain/Q/pregain (different from Tanchjim's 10x/1000x)
- **Filter types:** PK=2, LSQ=1, HSQ=3 (different codes than Tanchjim!)
- **Write sequence:** Write coefficient packet → Enable packet → Save to flash

**Protocol commands:**
- `0x80` - READ
- `0x01` - WRITE
- `0x09` - UPDATE_EQ (sub-command for filter write)
- `0x0A` - UPDATE_EQ_COEFF_TO_REG (enable filter)
- `0x23` - PRE_GAIN
- `0x03` - SET_DAC_OFFSET (read pregain)

**Device detection:** Multiple vendor IDs due to WalkPlay/Conexant chipset manufacturers. Handler matches by vendor ID + product name keywords (MOONDROP, RAYS, MARIGOLD, FREEDSP, etc.).

**Test fixtures:** Located in `cache/peq/moondrop/` including flat.json and generic test profiles

### Adding New Devices

To add support for a new device:

1. **Create handler** in `tools/peq_devices/handlers/<device>.py`:
   ```python
   from ..base import BaseDeviceHandler, DeviceCapabilities, PEQProfile

   class MyDeviceHandler(BaseDeviceHandler):
       name = "MyDevice Model"

       @property
       def capabilities(self) -> DeviceCapabilities:
           return DeviceCapabilities(
               max_filters=10,
               supports_read=True,
               supports_write=True,
               supported_filter_types={"PK", "LSQ", "HSQ"},
               gain_range=(-12.0, 12.0),
               q_range=(0.5, 10.0),
               freq_range=(20, 20000)
           )

       def read_peq(self, device) -> PEQProfile:
           # Implement HID read logic
           pass

       def write_peq(self, device, profile: PEQProfile) -> None:
           # Implement HID write logic
           pass
   ```

2. **Register handler** in `tools/peq_devices/handlers/__init__.py`:
   ```python
   from .mydevice import MyDeviceHandler

   HANDLERS = [
       TanchijimHandler,
       QudelixHandler,
       MyDeviceHandler,  # Add here
   ]
   ```

3. **Test detection**:
   ```bash
   python cli.py --list --debug
   ```

---

## HID Protocol Notes

### Command Structure

**Common commands:**
- `0x52` - READ (read current settings)
- `0x57` - WRITE (write filter data)
- `0x53` - SAVE/COMMIT (persist to device memory)
- `0x43` - CLEAR (reset filters)

**Report format:**
- Report ID: `0x4B`
- Packet size: 64 bytes
- Multi-packet transactions for reading/writing multiple filters

**Encoding:**
- Frequency: 16-bit unsigned integer (Hz)
- Gain: 16-bit signed integer (dB * 10, e.g., -25 = -2.5dB)
- Q factor: 16-bit unsigned integer (Q * 1000, e.g., 1410 = 1.41)
- Filter type: Single byte (`0x00` = PK, `0x01` = LSQ, `0x02` = HSQ)

**Timing:**
- COMMIT command requires ~1 second wait for device to save settings
- Use time.sleep(1.0) after COMMIT before disconnecting

---

## Skills

### eq-advisor

Located in `.claude/skills/eq-advisor/SKILL.md`

**Purpose:** Structured reasoning framework for IEM EQ adjustments

**When to use:**
- User wants to adjust sound presentation
- User asks to tune their IEMs
- User wants to achieve specific sound signature

**Workflow:**
1. Identify the IEM model
2. Fetch stock frequency response
3. Classify user intent (setting-based, mood-based, technical, relative)
4. Determine if adjustment is relative to current state or absolute target
5. Use MCP tools to compute and apply EQ

**IMPORTANT:** ALWAYS invoke the `eq-advisor` skill FIRST before using eq-advisor MCP tools directly when the user wants to adjust sound.

---

## Testing and Debugging

### Debug Mode

```bash
python cli.py --debug --list
```

Shows:
- Raw HID enumeration data
- Device matching logic
- Handler selection process
- Packet payloads (hex dumps)

### Testing MCP Servers

MCP servers run as stdio processes. To test manually:

```bash
# Test eq-advisor-mcp
cd tools/peq_devices
python server.py

# Send JSON-RPC request (stdin)
{"jsonrpc": "2.0", "method": "tools/list", "id": 1}
```

**Note:** MCP servers are designed for Claude Code integration, not direct CLI use.

### Common Issues

**Device not detected:**
- Ensure device is plugged in via USB
- Check `python cli.py --list --debug` for HID enumeration
- Verify device VID/PID matches handler definition

**"No preset data received":**
- Qudelix may need a brief delay between operations
- Try running the command again after 1 second

**MCP server not available:**
- Ensure you're in the `eq-advisor/` directory (project-scoped servers)
- Check `.mcp.json` has correct Python paths
- Restart Claude Code if servers were just added

---

## Development Guidelines

### Code Style

**Follow existing patterns:**
- Handler classes extend `BaseDeviceHandler`
- Use dataclasses for structured data (`PEQProfile`, `FilterDefinition`)
- Type hints for all function signatures

**HID communication:**
- Always use try/except for device.write() and device.read()
- Add time.sleep() after COMMIT commands
- Log raw packets in debug mode

### Adding Features

**Before implementing:**
1. Check `claude-self-dialog/` for existing design notes
2. Review `MULTI_DEVICE_GUIDE.md` for device architecture
3. Test with real hardware if possible

**When modifying handlers:**
- Update device capabilities if changing supported features
- Test read/write round-trip to verify encoding
- Add flat profile to `cache/peq/<device>/flat.json`

### Documentation

**Update when:**
- Adding new device support (update Supported Devices section)
- Adding MCP tools (update MCP Tools Reference)
- Changing CLI arguments (update CLI Usage)

---

## Known Limitations

- **macOS only** (uses hidapi, not tested on Windows/Linux)
- **USB HID only** (no Bluetooth support)
- **Qudelix defaults to USR EQ** (SPK and B20 groups accessible via handler API)
- **No GUI** (CLI and MCP only)

---

## File Naming Conventions

**EQ profiles:**
- `cache/peq/<device>/{iem}/{variant}/<profile>.json`
- Use lowercase with underscores: `harman_target.json`, `v_shaped.json`

**Documentation:**
- Claude development notes go in `claude-self-dialog/` (not shown to users)
- User-facing docs are README files or inline comments

**Handler files:**
- `tools/peq_devices/handlers/<manufacturer>.py`
- One file per manufacturer, handle multiple models in same class if protocol is shared

---

## Quick Reference

### Common Workflows

**Apply stored profile:**
```bash
python cli.py --json cache/peq/tanchjim-fission/moondrop-blessing-3/default/harman_ie_2019.json
```

**Read current settings:**
```bash
python cli.py --read
```

**Auto-EQ for specific IEM:**
```
1. Invoke /eq-advisor skill
2. Follow structured reasoning process
3. MCP tools handle the rest
```

**Create new profile:**
```json
{
  "name": "My Custom EQ",
  "pregain": -3,
  "filters": [
    {"freq": 100, "gain": 2, "q": 1.0, "type": "LSQ"}
  ]
}
```

### Environment

**All Components (unified environment):**
- Python: 3.11 (in `venv/`)
- HID library: hidapi>=0.14.0
- MCP: mcp>=1.0.0
- Optimization: scipy>=1.11.0 (for autoeq-mcp, autoeq, squiglink)
- HTTP: httpx (for squiglink-mcp API calls)

All packages installed once in unified `venv/lib/python3.11/site-packages/`

### Support

- Check `claude-self-dialog/` for implementation notes
- Tanchjim protocol is well-documented in `tanchjim.py` handler
